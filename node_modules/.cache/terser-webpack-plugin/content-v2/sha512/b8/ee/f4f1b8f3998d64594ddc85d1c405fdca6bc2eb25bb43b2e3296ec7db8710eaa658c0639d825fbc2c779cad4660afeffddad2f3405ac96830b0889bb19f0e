{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{432:function(v,_,r){\"use strict\";r.r(_);var t=r(56),n=Object(t.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[r(\"p\",[r(\"strong\",[v._v(\"！代替变量为0或null的情况\")])]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[r(\"strong\",[v._v(\"解构表达式代替临时变量交换\")])]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[v._v(\"利用二叉树表示一个算数表达式，根据二叉树的三种遍历可以得到3种算数表达式的方法：前缀表达式（波兰式）、中缀表达式、逆波兰表达式（后缀表达式）\")]),v._v(\" \"),r(\"p\",[v._v(\"逆波兰表达式可以利用栈求解\")]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[r(\"strong\",[v._v(\"求模运算和求幂运算的简化\")])]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[v._v(\"树的层次遍历：队列\")]),v._v(\" \"),r(\"p\",[v._v(\"满二叉树\")]),v._v(\" \"),r(\"p\",[v._v(\"完全二叉树\")]),v._v(\" \"),r(\"p\",[v._v(\"二叉树非递归遍历\")]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[r(\"strong\",[v._v(\"二叉排序树\")]),v._v(\"（\"),r(\"strong\",[v._v(\"二叉搜索树\")]),v._v(\"）：\")]),v._v(\" \"),r(\"ul\",[r(\"li\",[v._v(\"如果它的左子树不为空，那么左子树上的所有结点的值均小于它的根结点的值\")]),v._v(\" \"),r(\"li\",[v._v(\"如果它的右子树不为空，那么右子树上的左右结点的值均大于它的根结点的值\")]),v._v(\" \"),r(\"li\",[v._v(\"根结点的左子树和右子树又是二叉排序树。\")]),v._v(\" \"),r(\"li\",[v._v(\"中序遍历为升序\")])]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[v._v(\"平衡二叉树：具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\")]),v._v(\" \"),r(\"p\",[v._v(\"堆排序\")]),v._v(\" \"),r(\"p\",[v._v(\"最优二叉树\")]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[r(\"strong\",[v._v(\"&& 和 || 代替if操作\")])]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[r(\"strong\",[v._v(\"桶排序\")])]),v._v(\" \"),r(\"hr\"),v._v(\" \"),r(\"p\",[r(\"strong\",[v._v(\"前缀和数组\")])])])}),[],!1,null,null,null);_.default=n.exports}}]);","extractedComments":[]}