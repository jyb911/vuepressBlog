{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{411:function(e,t,v){\"use strict\";v.r(t);var _=v(56),r=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[v(\"h6\",{attrs:{id:\"vue双向绑定\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue双向绑定\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"Vue双向绑定\")])]),e._v(\" \"),v(\"p\",[v(\"a\",{attrs:{href:\"https://imgtu.com/i/q8Afdx\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v(\"img\",{attrs:{src:\"https://s1.ax1x.com/2022/03/24/q8Afdx.png\",alt:\"q8Afdx.png\"}}),v(\"OutboundLink\")],1)]),e._v(\" \"),v(\"p\",[e._v(\"指的是视图（view）与模型数据（viewmodel）双向绑定\")]),e._v(\" \"),v(\"p\",[e._v(\"对象有两种属性：数据属性和存取器属性（一组获取和设置值的函数get 或set）\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"get对应的方法为getter，负责获取值，不带参数\")]),e._v(\" \"),v(\"li\",[e._v(\"set对应的方法为setter，负责设置值，没有return\")])]),e._v(\" \"),v(\"p\",[e._v(\"Object.defineProperty(obj, prop, descriptor)\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"obj：必需。目标对象；\")]),e._v(\" \"),v(\"li\",[e._v(\"prop：必需。需定义或修改的属性的名字；\")]),e._v(\" \"),v(\"li\",[e._v(\"descriptor：必需。\"),v(\"strong\",[e._v(\"目标属性所拥有的特性\")]),e._v(\"；\")]),e._v(\" \"),v(\"li\",[e._v(\"返回obj\")])]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"Vue是采用数据劫持结合发布/订阅模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\")])]),e._v(\" \"),v(\"p\",[e._v(\"每当属性的set方法触发，就循环更新Dep中的订阅者\")]),e._v(\" \"),v(\"p\",[e._v(\"Vue 在更新 DOM 时是\"),v(\"strong\",[e._v(\"异步\")]),e._v(\"执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。\")]),e._v(\" \"),v(\"p\",[e._v(\"Vue 不允许动态添加根级响应式 property\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"observer用来实现对每个vue中的data中定义的属性循环用Object.defineProperty()实现数据劫持，以便利用其中的setter和getter，然后通知订阅者，订阅者会触发它的update方法，对视图进行更新\")]),e._v(\" \"),v(\"li\",[e._v(\"compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者\")]),e._v(\" \"),v(\"li\",[e._v(\"watcher订阅者在自身实例化时往属性订阅数组(dep)里面添加自己，在收到数据变化通知后调用update()函数，并触发compile中绑定的回调\")])]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"h6\",{attrs:{id:\"组件是可复用的-vue-实例\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件是可复用的-vue-实例\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"组件是可复用的 Vue 实例\")])]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"为什么一个组件的 \"),v(\"code\",[e._v(\"data\")]),e._v(\" 选项必须是一个函数\")])]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"组件在任何模块中都可以被引用，在使用的过程中，如果组件定义的变量是个对象，那么一个模块修改了该对象，其他模块也跟着修改了。如果使用函数，每次返回的是一个新的实例，每个模块引用的过程中都是针对本身的实例做修改，不会影响到其他模块的实例。\")]),e._v(\" \"),v(\"li\",[e._v(\"在vue中v-model，v-name，{undefined{}}等都可以对数据进行显示，也就是说假如一个属性都通过这三个指令了，那么每当这个属性改变的时候，相应的这个三个指令的html视图也必须改变，于是vue中就是每当有这样的可能用到双向绑定的指令，就在一个Dep中增加一个订阅者，其订阅者只是更新自己的指令对应的数据，也就是v-model='name'和{undefined{name}}有两个对应的订阅者，各自管理自己的地方。每当属性的set方法触发，就循环更新Dep中的订阅者。\")]),e._v(\" \"),v(\"li\",[e._v(\"compile的目的就是将各种指令解析成真正的html\")]),e._v(\" \"),v(\"li\",[e._v(\"首先我们为每个vue属性用Object.defineProperty()实现数据劫持，为每个属性分配一个订阅者集合的管理数组dep；然后在编译的时候在该属性的数组dep中添加订阅者，v-model会添加一个订阅者，{undefined{}}也会，v-bind也会，只要用到该属性的指令理论上都会，接着为input会添加监听事件，修改值就会为该属性赋值，触发该属性的set方法，在set方法内通知订阅者数组dep，订阅者数组循环调用各订阅者的update方法更新视图。\")])]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"组件通信\")])]),e._v(\" \"),v(\"p\",[e._v(\"props\")]),e._v(\" \"),v(\"p\",[e._v(\"子组件通过 $emit 触发事件\")]),e._v(\" \"),v(\"p\",[e._v(\"父组件通过 $event.target.value 访问子组件抛出的值\")]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"p\",[e._v(\"自定义组件名 (字母全小写且必须包含一个连字符)\")]),e._v(\" \"),v(\"p\",[e._v(\"组件名的两种命名方式\")]),e._v(\" \"),v(\"p\",[e._v(\"全局注册与局部注册\")]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"全局注册的行为必须在根 Vue 实例 (通过 \"),v(\"code\",[e._v(\"new Vue\")]),e._v(\") 创建之前发生\")])]),e._v(\" \"),v(\"p\",[e._v(\"动态组件 v-bind:is\")]),e._v(\" \"),v(\"p\",[e._v(\"HTML 元素对于哪些元素可以出现在其内部是有严格限制的，可以使用is属性来应对\")]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"h6\",{attrs:{id:\"虚拟dom\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#虚拟dom\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"虚拟DOM\")])]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"h6\",{attrs:{id:\"事件循环机制\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事件循环机制\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"事件循环机制\")])]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"h6\",{attrs:{id:\"异步更新队列\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#异步更新队列\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"异步更新队列\")])]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"h6\",{attrs:{id:\"vue生命周期\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue生命周期\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"vue生命周期\")])]),e._v(\" \"),v(\"p\",[v(\"a\",{attrs:{href:\"https://imgtu.com/i/qGChq0\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v(\"img\",{attrs:{src:\"https://s1.ax1x.com/2022/03/24/qGChq0.png\",alt:\"qGChq0.png\"}}),v(\"OutboundLink\")],1)]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"beforecreated：el 和 data 并未初始化，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据\")]),e._v(\" \"),v(\"li\",[e._v(\"created：实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组\")]),e._v(\" \"),v(\"li\",[e._v(\"beforeMount：完成了 el 和 data 初始化\")]),e._v(\" \"),v(\"li\",[e._v(\"mounted ：完成挂载\")]),e._v(\" \"),v(\"li\",[e._v(\"beforeUpdate：虚拟DOM中根据data变化去更新html\")]),e._v(\" \"),v(\"li\",[e._v(\"updated：将虚拟DOM更新完成的HTML更新到页面中\")]),e._v(\" \"),v(\"li\",[e._v(\"beforeDestroy：销毁之前调用\")]),e._v(\" \"),v(\"li\",[e._v(\"destroyed：销毁之后调用，之后再执行app.message= ‘hello vue’，页面不会同步更新。\")])]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"h6\",{attrs:{id:\"diff算法\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#diff算法\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"diff算法\")])]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"比较只会在同层级进行, 不会跨层级比较。\")])]),e._v(\" \"),v(\"p\",[v(\"code\",[e._v(\"sameVnode\")]),e._v(\"函数就是看这两个节点是否值得比较，两个vnode的key和sel（节点选择器）相同才值得去比较它们\")]),e._v(\" \"),v(\"p\",[v(\"a\",{attrs:{href:\"https://imgtu.com/i/qcoGOe\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v(\"img\",{attrs:{src:\"https://s1.ax1x.com/2022/03/30/qcoGOe.png\",alt:\"qcoGOe.png\"}}),v(\"OutboundLink\")],1)]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"h6\",{attrs:{id:\"渐进式框架\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#渐进式框架\"}},[e._v(\"#\")]),e._v(\" \"),v(\"strong\",[e._v(\"渐进式框架\")])]),e._v(\" \"),v(\"p\",[e._v(\"就是框架分层，最核心的是视图层渲染，然后往外是组件机制，在此基础上再加入路由机制，再加入状态管理，最外层是构建工具\")]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"vue中的$nextTick\")])]),e._v(\" \"),v(\"p\",[e._v(\"在下次 DOM \"),v(\"strong\",[e._v(\"更新循环结束之后\")]),e._v(\"执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\")]),e._v(\" \"),v(\"p\",[e._v(\"Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM\")]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"自定义事件\")])]),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"始终使用 kebab-case 的事件名\")])]),e._v(\" \"),v(\"hr\"),e._v(\" \"),v(\"p\",[v(\"strong\",[e._v(\"异步组件\")])]),e._v(\" \"),v(\"p\",[e._v(\"只在需要的时候才从服务器加载一个模块\")])])}),[],!1,null,null,null);t.default=r.exports}}]);","extractedComments":[]}