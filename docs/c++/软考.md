### 计算机系统

计算机硬件：运算器、控制器、存储器、输入输出设备

CPU主要由运算器、控制器、寄存器组、内部总线等组成

运算器：算数逻辑单元、累加寄存器、数据缓冲寄存器和状态条件寄存器等组成

控制器：指令控制逻辑、时序控制逻辑、总线控制逻辑、中断控制逻辑

原码

反码

补码：设计目的是使符号位 能与有效值部分一起参与计算，简化运算规则；补码的补码是原码

移码

浮点数表示

海明码：被校验的海明位下标等于所有参与校验该位的校验位的下标之和，是一种纠错码，用校验位的值决定被校验位的数据，m位数据位，k位校验位

Pi=Hj  j = 2^(i - 1) Pi表示校验位，Hj表示在海明码中的位置

k + m ≤ 2^k - 1

循环冗余校验

奇偶校验

模2运算

指令集：CISC和RISC

高速缓存位于CPU和主存之间

高速缓存的地址映像方法：直接映像、全相联映像、组相联映像

- 直接映像：主存的块和Cache的块对应关系固定，只能存放在Cache的相同块号中，不同区的相同块号同一时间只能有一块调入Cache
- 全相联映像：主存和Cahce均分成大小相同的块，用块号判断
- 组相联映像：组采用直接相联，块采用全相联

替换算法

对称加密：DES、AES

非对称加密：RSA

系统可靠度计算

软件质量属性

- 可靠性：系统对于给定时间间隔内、给定条件下**无失效运作**的概率。用MTTF/(1+MTTF)来度量，MTTF为平均故障时间
- 可用性：给定时间点，系统能够按照规格说明正确运作的概率。用MTBF/(1+MTBF)来度量，MTBF为平均失效间隔时间
- 可维护性：给定使用条件下，规定时间间隔内，使用规定的过程和资源完成维护活动的概率，用1/(1+MTTR)来度量，MTTR为平均修复时间

入侵检测系统

漏洞扫描系统

事务具有原子性、一致性、隔离性和持久性

- 原子性：
- 一致性：事务执行结果必须保证数据库从一个状态变到另一个状态
- 隔离性
- 持久性：一旦事务提交成功，即使数据库崩溃，对数据库的更新操作也永久有效

专利权和著作权

ROM和RAM

ROM：Read-Only Memory只读存储器

RAM：Random Access Memory随机存取存储器

文件系统

FAT：文件分配表

FAT32

NTFS

死锁必要条件：互斥、请求保持、不剥夺、环路等待

PV操作：通过信号量来控制进程执行顺序

P操作信号量-1，V操作信号量+1

寄存器、高速缓存、内存、外存

高速缓存和内存之间的地址映射由硬件实现，内存和外存之间的交互由软硬件结合实现

SRAM比DRAM速度更快，价格更高，用作高速缓存

DRAM用作内存

进程前趋图：有向无循环图，用于描述进程之间执行的前后关系

绝对路径从根目录\开始，相对路径从当前目录的下一级开始，不包含文件名

磁道、柱面、扇区

每个盘片被划分为多个磁道，一个圈就是一个磁道，每个磁道被划分为多个扇区

所有盘面中相对位置相同的磁道组成柱面

通过柱面、盘面、扇区定位磁盘块

同一文件分布在不同磁道上

I/O设备管理

1. 用户I/O
2. 设备无关I/O层
3. 设备驱动程序
4. 中断处理程序
5. 硬件

进程控制由操作系统内核中的原语实现

### 数据库

DBMS 数据库管理系统

ODBC 开放式数据库互连，为异构数据库访问提供统一接口，允许应用程序以SQL为数据存取标准，存取不同DBMS管理的数据

JDBC Java程序数据库连接

DDL Data Definition Language数据定义语言

DML Data Manipulation Language数据操纵语言

三级模式、两级映像

1. 概念模式，对应表
2. 外模式：用户与数据库系统的接口，对应视图
3. 内模式：数据物理结构和存储方式的描述，对应存储文件

模式/内模式映像

外模式/模式映像

数据模型是对现实世界数据特征的抽象

1. 概念数据模型：按用户的观点对数据和信息建模，主要用于数据库设计，如E-R实体-联系模型
2. 基本数据模型：按计算机系统的观点对数据建模，用于DBMS的实现，如层次模型，网状模型，关系模型和面向对象模型

数据模型三要素：数据结构、数据操作、数据约束条件

实体：矩形、联系：菱形、属性：椭圆

关系模型是一种数据模型

关系模式是关系的模式抽象，如学生（学号，姓名，年龄）

关系是一张表

域：属性的取值范围

关系中属性的个数为元数

元组的个数为基数

完整性约束：保证授权用户对数据库的修改不会破坏数据的一致性，防止对数据的意外破坏。

- 实体完整性：主键不为空
- 参照完整性：每个元组中外键如果是另一个关系中的主键，则它的值取空或等于另一个关系中某个元组的主键值
- 用户定义完整性：针对某一具体应用设计的数据必须满足约束条件

关系代数运算：并交差、笛卡尔积、投影、选择、连接、除、比较、逻辑

基本运算：并、差、笛卡尔积、投影、选择

- 投影：从关系中选出若干属性列形成新的关系
- 选择：从关系中选出满足给定条件的若干元组
- 连接：从两个关系的**笛卡尔积**中选取满足条件的元组

等值连接是连接在连接运算符为“=”时的特例

自然连接是一种特殊的等值连接，要求两个关系中进行比较的分量必须是**相同的属性组**并在结果中将**重复的属性列去掉**

除法运算：设有两个关系R(A, B)和S(B)，R÷S是一个新的关系T(A)，包含所有在R中存在且**满足S中所有条件**的A的值

事务是一个操作序列

- 原子性：要么都做，要么都不做
- 一致性：事务执行结果必须保证数据库从一个一致性状态变到另一个一致性状态
- 隔离性：事务间相互隔离，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的
- 持久性：事务一旦成功提交，即使数据库崩溃，对数据库的更新操作也永久有效

共享锁：又称读锁

排他锁：又称写锁

分布式数据库系统

- 共享性：数据存储在不同的节点数据共享
- 自治性：每个节点对本地数据独立管理
- 可用性：当某一场地故障时，系统可以使用其他场地上的副本而不至于整个系统瘫痪
- 分布性：在不同场地上存储

广义投影允许在投影列表中使用算术运算，实现了对投影的扩充

外连接是自然连接的扩展，可以处理由于连接而缺失的信息

- 左外连接：取出左侧关系张所有与右侧关系中任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性，构成的新元组加入到自然连接的结果中
- 右外连接：取出右侧关系张所有与左侧关系中任一元组都不匹配的元组，用空值填充所有来自左侧关系的属性，构成的新元组加入到自然连接的结果中
- 全外连接：完成左外连接和右外连接的操作

SQL

- 数据查询：SELECT
- 数据定义：CREATE、DROP、ALTER
- 数据操纵：INSERT、UPDATE、DELETE
- 数据控制：GRANT、REVOKE

基本表和视图都是表，基本表是实际存储在数据库中的表，视图是虚表，是从从其他表或视图导出的表，数据库中只存放视图的定义，不存放视图的数据

创建表

CREATE TABLE 表名（列名 数据类型 [列级完整性约束]...表级完整性约束）

修改表

ALTER TABLE 表名 [ADD 新列名 数据类型 完整性约束]

​                                [DROP 完整性约束]

​                                [MODIFY 列名 数据类型]

删除表

DROP TABLE 表名

建立索引

CREATE [UNIQUE] [CLUSTER] INDEX 索引名 ON 表名(列名 [次序]，列名 [次序]...)

删除索引

DROP INDEX 索引名

创建视图

CREATE VIEW 视图名 AS SELECT 查询子句 [WITH CHECK OPTION]

删除视图

DROP VIEW 视图名

查询

SELECT [ALL|DISTINCT] 目标列表达式

​               FROM 表名或视图名

​               [WHERE 条件表达式]

​               [GROUP BY 列名[HAVING条件表达式]]

​               [ORDER BY列名[ASC|DSC]]

SELECT对应的是关系代数中的投影运算，DINSTINCT保证查询结果中不存咋重复元组

FROM对应的是关系代数中的笛卡尔积

WHERE对应的是关系代数中的选择谓词		

分组查询

GROUP BY可以将元组进行分组，SELECT子句中使用的聚集操作符仅作用在每个分组上

HAVING子句将元组分组前按照某种方式加上限制，使不需要的分组为空

AS子句为关系和属性重新命名，既可以出现在SELECT子句，也可以出现在FROM子句

字符串操作，LIKE的模式匹配，‘%’匹配任意字符串，'_'匹配任意一个字符

数据更新

插入

INSERT INTO 表名 VALUES(常量); 查询语句

INSERT INTO 表名 SELECT 查询语句

删除

DELETE FROM 表名 [WHERE 条件表达式]

修改

UPDATE FROM 表名 SET 列名=值表达式 [WHERE 条件表达式]

访问控制

授权语句

GRANT 权限 [ON 对象类型 对象名] TO 用户 [WITH GRANT OPTION]

WITH GRANT OPTION：若指定此子句，获得了权限的用户还可以将权限赋给其他用户

| 对象   | 对象类型 | 操作权限                                                    |
| ------ | -------- | ----------------------------------------------------------- |
| 属性列 | TABLE    | SELECT、INSERT、UPDATE、DELETE、ALLPRIVILEGES               |
| 视图   | TABLE    | SELECT、INSERT、UPDATE、DELETE、ALLPRIVILEGES               |
| 基本表 | TABLE    | SELECT、INSERT、UPDATE、DELETE、ALTER、INDEX、ALLPRIVILEGES |
| 数据库 | DATABASE | CREATETAB建表                                               |

收回权限

REVOKE 权限 [ON 对象类型 对象名] FROM 用户

关系数据库的规范化，减少数据冗余避免更新异常

**函数依赖**：描述一个属性（属性集）对另一个属性（属性集）的依赖关系

X，Y表示属性（属性集），X -> Y 表示X决定Y

非平凡函数依赖：X -> Y，满足Y不包含于X

完全函数依赖f：X -> Y，对于X的任一真子集Z，都有Z不决定Y，则Y对X完全函数依赖

部分函数依赖p：X -> Y，存在X的一个真子集Z，Z决定Y，则Y对X部分函数依赖

传递函数依赖t：X -> Y，Y不决定X，Y -> Z，则X -> Z，则称Z对X传递函数依赖

关系模式R(U, F)，U为关系模式R中的属性集。F是U上的一组函数依赖

码：能唯一标识元组的属性或属性集合

候选码：K为R中的属性组合，若K->U，且K的任一真子集不决定U，则K为R的候选码                                                                                                                                                                                                                                                                                                                                                                                                                                                             

主属性：包含在候选码中的属性

全码：关系模型的所有属性组是候选码

外码：另一个关系的码

**规范化**

第一范式条件：所有的域都应是原子数据

第二范式：1NF消除了非主属性对码的部分函数依赖，所有非主属性完全函数依赖于任何候选码

第三范式：2NF消除了非主属性对码的传递函数依赖

**模式分解**

目的是将一个包含数据冗余和操作异常的不合适的关系模式转化为多个规范化的关系模式

对一个给定模式进行分解，使得分解后的模式是否与原来模式等价有三种情况

- 分解具有无损连接性，意味着分解后的关系模式在经过自然连接操作后，能够恢复原始的关系模式
- 分解保持函数依赖
- 分解既有无损连接性，又保持函数依赖

E-R模型向关系模型转换的规则

多对多联系需要单独转换为一个关系模式，也需要重新建类

派生属性：可以由其他属性经过运算得到的属性

多值属性：一个实体在该属性上会同时取多个属性值

### 面向对象方法

面向对象方法包括面向对象分析、面向对象设计和面向对象实现

类的分类：实体类、接口类、控制类

类间关系：

- 组合：整体与部分，不可分离
- 聚合：整体与部分
- 关联：
- 泛化：继承
- 依赖

多态：不同对象收到同一消息可以产生完全不同的结果

- 参数多态：模板
- 包含多态：虚函数
- 强制多态：强制类型转换
- 过载多态：重载

绑定：把过程调用和响应调用所需执行的代码加以结合

- 静态绑定
- 动态绑定

#### 面向对象分析

1. 认定对象
2. 组织对象：分析对象间的关系，将对象抽象成类
3. 描述对象间的相互作用
4. 确定对象的操作
5. 定义对象的内部信息

#### 面向对象设计

面向对象设计原则：

- 单一职责：一个类应只有一个引起它变化的原因，即只负责一项特定功能
- 开放封闭：对扩展开放，对修改封闭，即当软件需要适应新需求时，应通过添加新的代码而不是修改当前代码来实现
- 里氏替换：子类必须能够替换基类而不会引起程序行为的变化
- 依赖倒置：高层模块不应依赖于底层模块，应依赖于抽象
- 接口隔离：客户不应依赖于它不需要的接口

面向对象程序设计

对象间的消息传递，其中一种情况消息的名称就是对象中外界可知的方法名，通过调用对象方法传递消息参数

#### UML

UML（Unified Modeling Language）统一建模语言，面向对象标准建模语言，统一的语义和符号表示

UML的词汇表包含3中构造块：事物、关系和图

- 事物：对模型中最具代表性的成分的抽象
- 关系：把事物结合在一起
- 图：聚集了相关事物

UML中的四种关系：

1. 依赖：指向被用到类的带箭头虚线
2. 泛化：特殊/一般关系，指向父元素，空心箭头实线，ps：我理解是抽象
3. 关联：是一种结构关系，描述了一组链，链是对象之间的连接，组合和聚合
4. 实现：空心箭头虚线

UML13种图：

1. 用例图：从用户角度描述系统功能，展现用例、参与者及它们之间的关系（用例之间的扩展、包含、泛化关系，参与者和用例之间的关联关系，参与者之间的泛化关系）

   - 用例：用来描述系统提供给参与者的服务或功能

   - 扩展关系：将新的行为**加入**到已有用例中，新用例指向基础用例
   - 包含关系：被包含的用例为包含用例，使用包含用例的为基用例，表示用例之间的**使用**关系，基用例指向包含用例
   - 关联关系：描述参与者和用例之间的关系
   - 泛化关系：特殊/一般关系

2. 类图：描述系统中类的静态结构

3. 对象图：系统中多个对象在某一时刻的状态，静态快照

4. 状态图：描述状态到状态控制流，常用于动态特性建模

5. 活动图：是一种特殊的状态图，描述了业务实现用例的工作流程

6. 顺序图：对象之间的动态合作关系，强调对象发送消息的顺序，同时显示对象之间的交互

7. 协作图：描述对象之间的协作关系

8. 构件图：描述系统的静态实现视图

9. 部署图：定义系统中软硬件的物理体系结构

10. 包图：对构成系统的模型元素进行分组整理

11. 组合结构图：用于描述一个分类器的内部结构

### 设计模式

- 对象创建型：抽象工厂、生成器、原型、单例
- 类创建型：工厂方法
- 对象结构型：适配器、桥接、组合、装饰器、外观（Facede）、享元、代理
- 类结构型：适配器
- 对象行为型：责任链、命令、迭代器、中介者、备忘录、观察者、状态、策略、访问者
- 类行为型：解释器、模板

1. 抽象工厂：创建一系列相关或相互依赖的对象的接口，而无需指定他们具体的类
2. **生成器**：将一个复杂对象的构建和表示分离
3. 原型：用原型实例指定创建对象的种类，并通过复制原型创建新对象
4. 适配器：将一个类的接口转换成客户希望的另一个接口
5. **桥接**：将抽象部分与其实现分离，使他们都能独立变化
6. 组合：将对象组合成树形结构来表示部分与整体的层次结构
7. 装饰器：动态地给一个对象添加一些额外的职责
8. **外观**：定义了一个高层接口，为子系统中的一组接口提供一致的界面
9. **享元**：运用共享技术有效支持大量细粒度对象
10. 代理：为其他对象提供一种代理来控制对对象的访问
11. 责任链：使多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止
12. 命令：将一个请求封装成对象，使得可以用不同的请求对客户进行参数化
13. **解释器**：
14. 迭代器：提供一种方法顺序访问一个聚合对象中的各个元素，且不暴露对象的内部表示
15. 中介者：用一个中介者来封装一系列的对象交互。对象交互时直接与中介者进行交互
16. 备忘录：在不破坏封装性的前提下捕获一个对象的内部状态，并在对象外保存这个状态，之后可以将对象恢复到原先保存的状态
17. 观察者：定义对象间一种一对多关系，当一个对象的状态发生改变时，所有依赖于它的对象全部都得到通知并自动更新
18. 状态：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类
19. 策略：定义一系列算法，封装起来并可以相互替换
20. 模板方法：定义一个操作的算法骨架，将一些步骤延迟到子类中实现
21. 访问者：表示一个作用于某对象结构中个元素的操作，访问者为对象结构中的每一个类声明一个visit操作。访问者可以通过该元素的特定接口直接访问它，封装操作

##### 算法复杂度



循环队列容量为M，队列长度为(rear - front + M)%M

字符串KMP模式匹配算法：核心是找出模式串中每个字符前面有多少个字符和最开始的字符串相同

算法时空复杂度

线性表顺序存储，插入新元素平均移动n/2个元素，删除新元素平均移动(n-1)/2个元素

##### 图

有向图

无向图

完全图

强连通图

##### 树

已知前序和中序，可以确定唯一二叉树

已知后序和中序，可以确定唯一二叉树

满二叉树

完全二叉树

最优二叉树

二叉排序树（二叉搜索树）：左子树所有节点小于根节点，右子树所有节点大于根节点，中序遍历为有序序列

平衡二叉树：左右子树的高度差不超过1。当向二叉搜索树中插入新节点后，如果能保证是一个平衡二叉树，则可以减少平均搜索长度

B树（B-tree）：解决高频的I/O操作，是一种平衡多路查找树，可以对存储数据及逆行O(logn)的时间复杂度的查找、插入和删除

红黑树：解决平衡树在插入、删除等操作需要大量旋转来保持平衡

排序算法

```c++
//直接插入排序
void InsertSort(int data[], int n)
{
	int temp;
	for (int i = 1; i < n; i++)
	{
		if (data[i] < data[i - 1])
		{
			temp = data[i];
			data[i] = data[i - 1];
			int j;
			for (j = i - 2; j >= 0; j--)
			{
				if (data[j] <= temp)
				{
					break;
				}
				data[j + 1] = data[j];
			}
			data[j + 1] = temp;
		}
	}
}

//冒泡排序
void BubbleSort(int data[], int n)
{
	for (int i = n - 1; i >= 1; i--)
	{
		int flag = 1;
		for (int j = 1; j <= i; j++)
		{
			if (data[j - 1] > data[j])
			{
				int temp = data[j];
				data[j] = data[j - 1];
				data[j - 1] = temp;
				flag = 0;
			}
		}
		if (flag) return;
	}
}

//简单选择排序
void SelectSort(int data[], int n)
{
	int k, temp;
	for (int i = 0; i < n; i++)
	{
		k = i;
		for (int j = i + 1; j < n; j++)
		{
			if (data[j] < data[k])
			{
				k = j;
			}
		}
		if (k != i)
		{
			temp = data[i];
			data[i] = data[k];
			data[k] = temp;
		}
	}
}

//快速排序
int partion(int data[], int low, int high)
{
	int i = low, j = high, pivot = data[low];
	while (i < j)
	{
		while (i < j && data[j] > pivot)
		{
			j--;
		}
		data[i] = data[j];
		while (i < j && data[i] < pivot)
		{
			i++;
		}
		data[j] = data[i];
	}
	data[i] = pivot;
	return i;
}
void quickSort(int data[], int low, int high)
{
	if (low >= high) return;
	int loc = partion(data, low, high);
	quickSort(data, low, loc - 1);
	quickSort(data, loc + 1, high);
}

//希尔排序
void ShellSort(int data[], int n)
{
	int k = n;
	int* delta = (int*)malloc(sizeof(int) * n / 2);
	int i = 0;
	while (k > 0)
	{
		k = k / 2;
		*(delta + i) = k;
		i++;
	}
	i = 0;
	int dk, j;
	while (delta[i] > 0)
	{
		dk = delta[i];
		for (int m = dk; m < n; m++)
		{
			if (data[m] < data[m - dk])
			{
				int temp = data[m];
				data[m] = data[m - dk];
				for (j = m - 2*dk; j >= 0 && data[j] > temp; j -= dk)
				{
					data[j + dk] = data[j];
				}
				data[j + dk] = temp;
			}
		}
		i++;

	}
}
```

动态规划

```c++
//最少硬币问题
const int Max = 1000;//总钱数
const int m = 5;
int type[m] = { 1, 5, 10, 25, 50 };//面值
int dp[Max];//所需最少硬币数量
void solve() 
{
	for (int k = 0; k < Max; k++)
	{
		dp[k] = INT_MAX;
	}
	dp[0] = 0;
	for (int i = 0; i < m; i++)
	{
		for (int j = type[i]; j < Max; j++)
		{
			dp[j] = min(dp[j], dp[j - type[i]] + 1);
		}
	}
}

//0/1背包问题
/*
n为物品数量，W为背包容量
*/
int** KnapsackDP(int n, int W, int * Weights, float* Values)
{
	int i, w;
	int** c = (int**)malloc(sizeof(int*) * (n + 1));
	for (i = 0; i <= n; i++)
	{
		c[i] = (int*)malloc(sizeof(int) * (W + 1));
	}

	for (w = 0; w <= W; w++)
	{
		//0个物品
		c[0][w] = 0;
	}
	for (i = 1; i <= n; i++)
	{
		//背包容量为0
		c[i][0] = 0;
		for (w = 1; w <= W; w++)
		{
			if (Weights[i - 1] <= w)//物品重量小于背包容量
			{
				//放
				if (Values[i - 1] + c[i - 1][w - Weights[i - 1]] > c[i - 1][w])
				{
					c[i][w] = Values[i - 1] + c[i - 1][w - Weights[i - 1]];
				}
				else 
				{
					c[i][w] = c[i - 1][w];
				}
			}
			else
			{
				c[i][w] = c[i - 1][w];
			}
		}
	}
	return c;
}

//最长公共子序列
int** LCS(const char* str1, const char* str2, int str1_length, int str2_length)
{
	int i, j;
	int** l = (int**)malloc(sizeof(int*) * (str1_length + 1));
	for (i = 0; i <= str1_length; i++)
	{
		l[i] = (int*)malloc(sizeof(int) * (str2_length + 1));
	}

	for (i = 0; i <= str1_length; i++)
	{
		l[i][0] = 0;
	}
	for (i = 0; i <= str2_length; i++)
	{
		l[0][i] = 0;
	}

	for (i = 1; i <= str1_length; i++)
		for(j = 1; j <= str2_length; j++)
		{
			if (str1[i - 1] == str2[i - 1])
			{
				l[i][j] = l[i - 1][j - 1] + 1;
			}
			else if (l[i - 1][j] >= l[i][j - 1])
			{
				l[i][j] = l[i - 1][j];
			}
			else
			{
				l[i][j] = l[i][j - 1];
			}
		}
	return l;
}
```

### 案例题型分析

重点：

1. 数据流图
2. 概念数据模型
3. 设计模式
4. C、C++、Java编程

### 结构化开发方法

结构化开发：由结构化分析、结构化设计、结构化程序设计构成，面向数据流

#### 数据流图

- 数据流：表示数据流向，加工到加工，加工到数据存储（写），数据存储到加工（读），加工到外部实体（输出），外部实体到加工（输入），实体之间、数据存储和实体之间没有数据流
- 加工：一个加工至少有一个输入数据流和一个输出数据流
- 数据存储
- 外部实体

OSI7层模型

- 物理层：中继器、集线器
- 数据链路层：网桥、交换机
  - 网桥：帧过滤
  - 交换机：根据MAC地址进行转发
- 网络层：路由器（连接多个逻辑上分开的网络）
- 传输层
- 会话层
- 表示层
- 应用层：网关（连接不同类型且协议差别较大的网络）

### Java基础

javac将Java源文件编译为class字节码文件

Java不使用指针，而是引用；提供自动分配和回收内存，只支持类间单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制；Java全面支持动态绑定，C++只对虚函数使用动态绑定

类名首字母大写，源文件名和类名相同，所有Java程序由public static void main(String[] args)方法开始执行，由JVM调用

一个源文件只能有一个public类，可以有多个非public类，源文件名应与public类名一致

#### 内置数据类型

- byte（-128~127）
- short
- int
- long
- float
- double
- char 16位Unicode字符
- boolean 默认值为false

#### 引用数据类型（类、接口、数组）

默认值为null

常量用final修饰

#### 数据类型转换

- 整型、浮点数、字符型数据可以混合运算
- 不能对boolean类型进行类型转换
- 不能把对象类型转换为不相关类的对象
- 把容量大的类型转换为容量小的类型必须使用强制类型转换
- 自动类型转换必须满足转换前的数据类型位数低于转换后的数据类型

整数的默认类型是int

小数默认是double

#### 访问控制修饰符

默认同一包内可见

- 父类中声明为public的方法子类中必须为public
- 父类中声明为protected的方法子类中为public或protected
- 父类中声明为private的方法子类不能继承

#### 非访问控制修饰符

- static：修饰类方法和类变量
- final：用来修饰类、方法、变量，final修饰的类不能被继承，修饰的方法不能被子类重定义，修饰的变量不可修改一个类不能同时被abstract和final修饰
- abstract：创建抽象类和抽象方法

- synchronized：声明的方法同一时间只能被一个线程访问
- transient：序列化对象包含被transient修饰的变量时，JVM跳过该特定变量
- volatile：修饰的成员变量每次被线程访问时，都强制从共享内存中重新读取该变量的值；当变量发生变化时，会强制将变化值写到共享内存。Java内存模型中，不同线程有自己独立的工作内存副本，当一个线程修改了共享变量的值后，另一个线程可能无法立即看到这个修改后的值

#### 包装类

抽象类Number，子类Byte、Short、Integer、Long、Float、Double

Character和Boolean

Math类

String类一旦创建，其值无法改变

StringBuffer和StringBuilder的对象能够被多次修改，且不产生新的未使用对象

StringBuilder不是线程安全的

Date类

Calendar抽象类

Calendar的getInstance()方法返回一个默认当前语言环境和时区初始化的GregorianCalendar类对象 

BufferReader read()和readLine()方法

InputStreamReader

控制台输出

PrintStream类方法print()和pringln()，System.out是该类对象的一个引用

PrintStrem继承OutputStream并实现了方法write()，将低八位写到流中

流：数据序列，输入流用于从源读取数据，输出流用于向目标写数据

- IO流
  - 字符流
    - Reader
      - BufferReader
      - InputStreamReader字节流转字符流
    - Writer
      - BufferWriter
  - 字节流
    - InputStream
      - FileInputStream
    - OutputStream
      - FileOutputStream

File类 目录或文件

Scanner获取用户输入的字符串

```java
Scanner s = new Scanner(System.in);
```

- next()：空白分隔
- nextLine()：回车分隔
- nextInt()：回车分隔
- nextFloat()：回车分隔

#### 异常处理

- throw：用于在代码中抛出异常
- throws：用于在方法声明中指定可能会抛出的异常类型

#### 接口

- 接口包含类要实现的方法
- 实现接口的类必须实现接口内所有方法，否则就必须声明为抽象类
- 接口不能实例化对象
- 没有构造方法
- 接口中所有方法必须是抽象方法，Java8后可以使用default修饰的非抽象方法，
- 接口中不能包含成员变量，除了static和final变量
- 允许将方法定义为private，使得某些复用代码不会把方法暴露出去
- 接口隐式抽象，声明时不必使用abstract

#### 枚举类

- 枚举值为public static final
- 拥有自己的变量、方法和private构造函数

#### 包

- 类似于C++命名空间

- 使用通配符*导入整个包时，只会导入包中的类，不会导入包中的子包

- 编译器为包中包含的每个类、接口等类型各创建一个不同的输出文件

  ```bash
  $javac -d . Runoon.java
  ```

#### 反射

- 允许程序运行时查询、访问、修改类、接口、字段和方法的信息

- 获取Class对象

  ```java
  //通过类字面量
  Class<?> clazz = String.class;
  //通过对象实例
  Class<?> clazz = str.getClass();
  //通过Class.forName方法
  Class<?> clazz = Class.forName("java.clang.String");
  ```

- 创建对象

  ```java
  Class<?> clazz = Class.forName("java.clang.String");
  Object obj = clazz.getDeclaredConstructor().newInstance();
  ```

- 访问字段

  ```java
  Class<?> clazz = String.class;
  Field field = clazz.getDeclaredField("name");
  field.setAccessible(true);
  ```

- 调用方法

  ```java
  Class<?> clazz = String.class;
  Method method = clazz.getMethod("lenth");
  method.invoke();
  ```

- 获取构造函数

  ```java
  Class<?> clazz = String.class;
  Constructor<?> constructor = clazz.getConstructor(String.class);
  Object obj = constructor.newInstance("someone");
  ```

- 获取接口和父类

  ```java
  Class<?> clazz = String.class;
  Class<?>[]  interfaces = clazz.getInterfaces();
  Class<?> superClass = clazz.getSuperclass();
  ```

#### 数据结构

- 数组
- ArrayList：动态数组
- LinkedList：双向链表
- HashSet：无序集合，基于HashMap实现
- TreeSet：有序集合，基于红黑树实现
- HashMap：无序，基于哈希表
- TreeMap：有序，基于红黑树
- Stack
- Queue：PriorityQueue
- 堆用PriorityQueue实现
- TreeNode

#### 泛型

#### 序列化

#### 网络编程

- 服务器实例化一个ServerSocket对象，表示通过服务器上的端口通信
