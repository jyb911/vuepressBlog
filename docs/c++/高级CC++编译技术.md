## 高级C/C++编译技术

### 虚拟内存

运行时的物理内存会被划分成分段（页），每一页都可用来同步执行程序

正在运行的程序的完整内存布局会被保存在硬盘中，只有那些当前即将被执行的一部分代码和数据才会被加载到物理内存的页中

### 进程内存划分

- 代码节（.text节）：供cpu执行的机器指令
- 数据节：供cpu操作的数据，初始化数据.data，未初始化数据.bss，只读数据.rdata
- 堆：动态内存分配
- 栈：为各个函数提供独立存储空间
- 最上层部分属于内核区域，存放特定进程的环境变量

### 编译

编译单元通常是指一个单独的源文件（通常是.cpp文件），它包含了所有被编译成目标代码的信息

编译器会将每个cpp文件单独编译成对应的汇编代码.s文件

头文件不被编译，但预处理器会在编译过程中递归包含，从而形成一个包含所有必要信息的单个源文件

#### 编译各个阶段

1. 预处理 .i
2. 词法分析：将源代码分割成不可分割的单词
3. 语法分析：将单词连接成序列，根据语法规则判断顺序是否合理
4. 语义分析：判断符合语法规则的语句是否具有实际意义
5. 汇编：将标准语言集合转换成特定CPU指令集的语言集合，.s
6. 代码优化
7. 代码生成：生成目标文件（.o），每个目标文件对应一个编译单元，汇编指令在此阶段转换为机器指令

#### 目标文件

- 符号和节是目标文件的基本组成部分，其中**符号**表示的是程序的内存地址或数据内存

- 目标文件中独立的节都可能包含在最终的程序内存映射中，因此目标文件中每个节的起始地址都会被临时设置为0，链接阶段才会确定程序内存映射中每个独立节的实际地址范围

### 链接

链接是将独立的节组合成最终的程序内存映射节，同时解析所有引用                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

进程内存映射：从0地址开始存放的各种节

#### 重定位

重定位将目标文件中的节拼接到程序内存映射节中，目标文件节中从0开始的地址范围转换成最终程序内存映射中更具体的地址范围

#### 解析引用

1. 未知实际程序内存地址的符号会被当成未解析引用
2. 计算该引用的精确地址
3. 将机器指令中的伪地址替换成程序内存映射的实际地址

### 可执行文件

- 可执行文件由启动例程、各种节、运行时堆、共享库的内存映射区域、用户栈、内核代码和数据、特定进行的数据结构组成
- 可执行文件结构布局遵循特定目标平台的可执行文件格式
- 可执行文件并**不完全是**通过编译项目源代码文件生成，启动程序的一部分代码片段在链接阶段才添加到程序内存映射的起始处，即启动例程

### 装载

- 装载器会打开可执行文件读取节的相关信息并载入到进程内存映射结构中
- 装载器还会根据节的相同装载需求将链接器创建的**节**组合成**段**

### 静态库

静态库实际上是二进制目标文件集合，通过编译器编译源代码并将生成的目标文件打包生成后的归档文件

#### 静态库转换为动态库

#### 静态库在64位Linux上的问题

- 将静态库链接到可执行文件64位Linux和32位Linux相同
- 将静态库链接到共享库要求静态库使用-fPIC或-mcmodel-large编译器选项进行构建，因为使用32位寄存器的编译汇编器无法访问64位平台地址偏移范围

### 动态库

1. 动态库装载时重定位（LTR），动态库通过操作系统动态链接模块提供，每个应用程序都需要加载一份自己的动态库副本。导致这种限制的原因是LTR为了实现向应用程序特定地址映射的功能，会修改动态库中的.text节的符号，这样导致其他应用程序载入动态库的地址范围不同，需要修改自身适用的动态库副本
2. 共享库位置无关代码（PIC，Position Independent Code），通过修改动态库代码访问符号的方式，只需要提供一份加载到某一进程中内存映射的动态库副本，就能映射到任何应用程序进程中
3. 链接器在构建时只会查找动态库库中的符号，并默认所有的符号都能够被正确解析，只有在加载时才会将动态库的段集成到可执行文件中
4. 动态链接构建时与运行时之间应用程序二进制接口的不变性是动态链接成功的最基本要求

#### 名称修饰

- 将函数名、函数的从属信息、函数的参数列表进行组合，最后生成符号名称

##### C风格函数

- C函数不需要名称修饰，但链接器会默认创建带修饰的名称
- extern "C"关键字，链接器会创建不带修饰的符号名称

#### 静态初始化顺序问题

- 初始化对象依赖于另外一些需要在其之前初始化的对象
- 没有规则可以指定静态对象的初始化顺序

##### 非局部静态对象

1. 定义在全局或命名空间作用域中
2. 定义为类中的静态变量
3. 定义为文件作用域中的静态变量

##### 解决方案

将对象声明为函数内部的静态变量，调用该函数第一次遇到变量定义时初始化

1. 在_init()函数中自定义实现，这是一个动态库加载时会被立即调用的标准函数
2. 调用自定义函数访问特定对象

***

#### 导入库文件

- 导入库文件（.lib）该文件只含有dll符号列表，并不包含链接器所需要的节
- 导出dll符号

#### 导出文件（.exp）

- 在构建两个可执行文件并出现循环依赖问题时使用

#### 控制动态库符号的可见性

- 默认情况下，windows dll链接器符号都是外部不可见的，Linux中所有动态库的链接器符号都是外部可见的。实际上，最终只有包含应用程序二进制接口的链接器符号是外部可见的，其余符号则是隐藏且外部不可见的

##### __desclspec(dllexport)关键字

- 导出头文件既可以动态链接库中使用，也可以在可执行程序中使用。在动态链接库中使用时，特定的宏被扩展成__desclspec(dllexport)关键字，在可执行程序中使用时，被扩展成 \__desclspec(dllimport)
- 关键字修饰的函数的链接器符号被置为对外可见

#### 动态链接模式

- 不同的程序生命周期中都可以进行动态库的链接

1. 加载时动态链接，编译和链接应用程序时提供头文件 (.h) 和导入库文件 (.lib)
2. 运行时动态链接，无需使用导入库文件，应用程序调用 `LoadLibrary` 函数或 `LoadLibraryEx` 函数以在运行时加载 DLL， 成功加载 DLL 后，可以使用 `GetProcAddress` 函数获取要调用的导出的 DLL 函数的地址。

#### Windows运行时动态库文件定位规则

- 与应用程序二进制文件在同一目录下
- 系统动态链接库目录之一

### 静态库和动态库对比

|              | 静态库                                                       | 动态库                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 导入选择条件 | 不会把整个静态库内容链接进来，只会来链接目标文件中的必要符号 | 会将整个动态库链接进来，选择包含在符号表中实际需要的动态库符号 |
| 构建过程     | 不完整，编译但不链接                                         | 完整，编译并链接                                             |
| 使用场景     | 算法模块；不依赖于某个需要特定的载入动态库的操作系统资源     | 链接一个动态库需要多个动态库；单例模式                       |
| 链接规则     | 从传递给链接器的静态库列表的最后一个静态库开始依次链接，只链接包含客户二进制文件实际所需符号的目标文件 |                                                              |

