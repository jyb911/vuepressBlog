pri文件：模块化 管理头文件，将.pro文件中的一部分放到pri文件中直接引用

Q_DECL_EXPORT导出类，生成.dll的同时生成.lib文件，提供外部接口供其他类使用

构建是巴开发环境代码转换为生产环境

```properties
.pro文件
TEMPLATE 生成文件的类型，“app”生成应用程序，“lib”生成库文件
TARGET 生成的应用程序名
CONFIG 配置信息
CODECFORSRC 源代码编码方式
UI_DIR 将.ui文件转换为ui_*.h文件的存放目录
RCC_DIR 将.qrc文件转换为qrc_*.h文件的存放目录
MOC_DIR 将含Q_OBJECT的头文件转换成标准.h文件的目录
OBJECTS_DIR 目标文件存放位置
DEPENDPATH 程序依赖路径
INCLUDEPATH 头文件包含路径
HEADERS 工程中的头文件
SOURCEAS 工程中的源文件
FORMS 工程中的ui设计文件
RESOURCES 工程中的资源文件
LIBS 引入lib文件，指定程序编译时需要链接的外部库
DEFINES 定义编译选项，添加后可以使用#ifdef
RC_FILE 定义资源文件
DESTFILES 指定要包含在dist中的文件列表
```

C++编译器默认识别不了JS，通过QT提供的QJSEngine类来执行JS

.dll dynamic link library 动态链接库

,exp 包含有关从dll导出的信息

.ilk 被链接器使用

.lib 动态库到处说明

.pdb 包含调试信息

静态成员函数只能访问静态成员

普通成员函数只能通过对象调用

静态成员函数不需要创建对象，可以通过类直接调用，根本区别this指针的有无

Qt国际化 tr

QStackedLayout实现多页面切换

继承关系QObject ->QCoreApplication-> QGuiApplication-> QApplication

部件的大小策略（setSizePolicy）、大小限制（setMaximumWidth）、拉伸因子（setStretchFactor）

MSVC：微软的VC编译器（pc端开发）

MinGW：跨平台开发，允许在GUN/Linux/Windows平台开发

MinGW续下载cmake自行编译

GUN：类Unix操作系统，属自由软件集，主要组件包括：GUN编译器集合、GUN C库、GUN文本编译器等

```properties
make，makefile，cmake， qmakepro
1. make是用来执行makefile的
2. makefile是类Unix的项目管理工具，对windows不友好，于是有了cmake
3. cmake是跨平台项目管理工具，在windows下生成projects文件，在Linux下生成Makefile文件
4，qmake是Qt专用项目工程管理工具，生成.pro文件，在Linux下生成Makefile文件
```

Windows平台Qt Creator由Visual Studio编译生成的程序（用MSVC编译器），Qt Creator编译程序时默认使用MinGW（安装Qt时自动下载）

Windows Software DevelopmentKit（SDK）不会随Visual Studio一同安装，需要从Microsoft网站下载

大端模式：高字节放低地址，低字节放高地址，地址从小到大增加，数据从高到低读取

优势：符号位判定固定在第一字节，容易判断正负

小端模式：低字节放低地址，高字节放高地址，将地址高低和数据位权有效结合，高地址部分权值高，低地址部分权值低

优势：强制转换数据不需要调整字节内容

对于ui文件，Qt有解释工具uic将ui文件转为.h文件，在编译时会执行uic，生成ui_xxx.h

其中setup函数将控件传递给参数，是由.ui文件生成的类的构造函数

Designer创建出来的对象没有基类，通过setup设置基类类型，然后ui对象就添加到基类中，ui对象可以操作所有子控件对象（因为在ui中子控件都是public域）

反射机制是指在运行时，能获取任意一个类对象的所有类型信息、属性、成员函数等信息的一种机制

元对象是指用于描述另一个对象结构的对象

QMetaObject类描述了QObject及其派生类对象的所有元信息

QMetaMethod描述成员函数

QMetaProperty 描述属性

自定义插件

1. 定义一组用于与插件对话的接口（仅具有纯虚函数的类）
2. 使用Q_DECLARE_INTERFACE宏向Qt元对象系统声明该接口
3. 在应用程序中使用QPluginLoader加载插件
4. 使用qobject_cast()测试插件是否实现了给定接口

编写插件

1. 声明一个插件类，该类继承自QObject和该插件要提供的接口
2. 使用Q_INTERFACE告诉元对象系统有关接口信息
3. 使用Q_PLUGIN_METADATA宏导出插件
4. 实现插件接口

update触发paintEvent事件

QGraphicsScene图形场景

QGraphicsItem图形对象

QGraphicsView，将QGraphicsScene作为QGraphicsView的场景

QPointF是点的浮点型版本，QPoint是点的整型版本

QPainter绘制器，执行绘制操作

QPaintDevice抽象绘图设备，如QWidget、QImage、QPainter

QPaintEngine绘图引擎，提供QPainter绘制在不同设备上的接口

多次update()触发的绘制事件会被Qt合并成一个事件统一处理

repaint不允许这种优化

QPaintPath类是一个容器，可把图形形状保存需要时可重复使用，因此不可将创建路径操作放在paintEvent函数中

DPI Dots Per Inch点每英寸

PPI Pixel Per Inch像素每英寸

QImage图像，可以直接访问和操控像素

QPixmap像素图，不能直接访问和操控像素

QBitMap位图，用于处理颜色深度为1的图像，继承自QPixmap

QPicture图片

将图像设置为标签或按钮的图标，或使用QPainter的draw方法使图像显示出来

QPixmap、QImage、QPicture都是绘制设备，可在其上直接绘制图形，因为这些绘制设备都不是QWidget部件，因此可以不在paintEvent中绘制

针对QLabel显示图片不全的问题涉及到QLabel的一个属性ScaledContents，决定是否缩放label的内容，默认为false，所以只显示像素图的一部分，通过setScaledContents设置为true即可显示完整图片

QSharedMemory用于在多个线程和进程之间共享内存段

QDataStream用于进行二进制数据流操作，起到类似于数据流管道的作用

QBuffer用于在内存中存储数据，可以看作一个特殊的IO设备

Qt Designer中使用自定义控件

- 提升法：将自定义控件定义好后，在Qt Designer中先添加一个它的父类控件，再进行提升
- 插件法：自定义控件中QDESIGNER_WIDGET_EXPORT确保Qt Desiner可以在所有平台上创建组件实例

Qt插件

QDesignerCustomWidgetInterface提供了一个带有界面的自定义小部件。该类包含一组必须子类化的函数，以返回有关小部件的基本信息，例如其类名和头文件名。必须实现其他函数，以便在加载插件时对其进行初始化，并构造自定义小部件的实例供Qt Designer使用。
在实现自定义小部件时，您必须子类化QDesignerCustomWidgetInterface，以便将小部件暴露给Qt Designer

QT_CONFIG实现了在编译时期的安全检查，检查指定的Qt特性是否存在或是否可利用

影子构建（shadow-build）：使用该模式会使编译生成的文件和源代码分别存放

若修改了.pro文件，建议重新构建该项目文件，否则对项目文件的更改不会反映到程序中

默认情况下控件不可见

源文件为空时构建仍会生成ui文件对应的头文件，头文件中，namespace Ui中的类和头文件中的同名类不是同一个类，Ui::dg定义于ui_dg.h内，头文件中只是一个前置声明

构建：即编译，只编译有变化的部分

重新构建：把所有部分重新编译

运行即调用构建生成的exe文件

qmake -project生成.pro文件

qmake生成makefile文件

mingw32-make生成release版本

mingw32-make -f Makefile.Debug生成debug版本

无法定位输入点：可能缺少libstdc++-6.dll

发布Qt Quick程序，需要用qmldir参数指定qml的安装目录

windeployqt D:\qt\xxx.exe --qmldir F:\Qt\qml

项目中的第三方库如opencv，仍需要手动拷贝所需dll，可用Dependency Walker查看缺少那些dll文件

Enigma Virtual Box程序封装

元对象：用来存储类的结构信息的对象

类的结构信息存储在一个类型为QMetaObject名为staticMetaObject的全局变量中

要想函数被反射，定义Q_INVOKABLE宏

要想成员变量被反射，定义Q_PROPERTY宏

反射机制--动态灵活

qobject_cast将QObject类型转换为目标类型

对象树中，子对象通常创建在堆中，使用new创建；父对象通常创建在栈上，使用A ma创建

QObject -> QCoreApplication -> QGuiApplication -> QApplication

QCoreApplication 提供无GUI程序的事件循环

QGuiApplication 管理GUI程序流

setWindowFlags改变窗口的基本属性

被添加到layout中的widget不需要指定父对象，它会自动reparent到layout install的widget上

SQLite是一种轻量级的嵌入式数据库引擎，它提供了一个自包含、零配置、事务性的关系数据库管理系统，Qt种的QSQLite模块

QSqlRelationTableModel允许表的列作为其他表的外键，如果想读写model，可在view上使用代理

设置外键setRelation

设置代理 setItemDelegate

数据 -> model ->tableview -> 设置代理

​    setTable    setModel

QSqlRelationDelegate为展示和编辑来自QSqlRelationTableModel的数据提供代理

createEditor在设置数据代理时被调用，用于创建编辑器

editorEvent在QTableView等控件中显示编辑模式时调用

Clang-Tidy是一个C++预处理器和编译器优化工具，可以自动检测并修复C++代码中如命名冲突、类型错误、重复代码、语法错误、内存泄漏等常见错误

Clazy是一个专为Qt设计的静态代码分析器

QStringRef对象提升QString处理子串的效率，避免内存分配和引用计数，是QString子串的引用，如果原始QString不存在，QStringRef也不合法

POD：Plain Old Data用来表示C++中与C兼容的数据类型，所有POD类型都可以作为union成员，所有非POD都不能作为union成员

**Q_GLOBAL_STATIC**            

避免在构造函数和析构函数中调用虚函数

Qt采用copy-on-write隐式共享特性，在Qt容器类中使用基于范围的for循环时，由于for内部调用了begin()和end()函数，会产生一个非const的容器对象从隐式共享的数据中分离出来，从而出现容器类深拷贝的情况，使用qAsConst或const

qAsConst将非常量左值转换为常量左值

QXmlStreamReader用于解析XML文档，提供了一种基于流的方式，可以逐个读取XML元素并进行处理

startDocument文档开始 startElement XML元素的开始标签

多语言界面

1. 字符串用tr()封装
2. .pro中设置.ts文件，使用lupdate生成，.ts翻译文件包含项目文件中需要翻译的字符串
2. 用Linguist程序翻译
2. 使用lrealease编译翻译好的翻译文件生成.qm文件
2. 用QTranslator调用.qm文件

MinGW（Minimdist GUN for Windows）是windows平台上使用GUN工具集导入库的集合

UMP Universed Windows Platform

调试器GUN gdb for MinGW和windows的CDB调试器

Windows Software Development Kit（SDK）

.ui文件 XML格式

Qt Designer工具栏

Edit Widget（F3）编辑状态

Edit Signal/Slots（F4）信号槽可视化设计

Edit Buddies 设置一个label与一个组件成为伙伴关系

QSignalMapper 将多个信号映射到一个槽函数上

只有当信号关联的所有槽函数执行完毕之后，才会执行发射信号处后面的代码

当一个信号被发射时，与其关联的槽函通常被立即执行，就像正常调用一个函数一样

信号clicked(bool)会将组件当前的选择状态作为一个参数传递

Qt Designer在setUi()中通过connectSlotsByName()将界面上的所有信号与槽函数关联起来

为应用设置图标，将图标文件复制到项目源程序目录下，在.pro中设置RC_ICONS=appIcon.ico

对象的属性和对象的成员变量有什么区别？

类是抽象的，定义了对象的结构和行为，包括属性和方法

对象是具体的，有不同的状态的行为

对于具有不同参数的同名信号，不能采用函数指针的方式进行信号槽关联

connect最后一个参数Qt::ConnectionType

Qt::AutoConnection

Qt::DirectConnection：slot函数在发出信号的线程中执行

Qt::QueuedConnection：slot函数在信号接收者的线程中执行

槽函数中，使用QObject::sender获取信号发射者的指针

QTread中，start()开始执行工作线程的任务，start()会在内部调用run()函数，进行工作线程的事件循环，在run()中调用exit()或quit()结束线程的事件循环，主线程中调用terminate()强制结束线程

QMutex lock()、unlock()、trylock()

QMutexLocker的构造函数接收一个互斥量作为参数并将其锁定，其析构函数则将此互斥量解锁

QReadWriteLock多个线程以只读方式同步访问资源，但同一时间只有一个线程可写

lockForRead()读的时候可以允许多个，但不允许写

lockForWrite()写的时候不允许读写

QReadLocker QWriteLocker构造函数接受一个QReadWrite指针作为参数，析构函数解锁

线程使用完锁并释放时，系统会自动唤醒挂起的线程

QWaitCondition可以在一个线程满足一定条件时通知其他多个线程，使它们及时做出响应

wait(QMutex* lockedMutex)先解锁，使其他线程可以使用lockedMutex，然后等待唤醒条件，被唤醒后再锁定并退出函数，执行后面的语句

唤醒条件wakeAll()

信号量QSemaphere

accquire阻塞地获取资源，如果没有则阻塞直到资源可用

带指针数据成员的类需要自己实现：拷贝构造函数，赋值构造函数、析构函数

CMake用于生成对应平台的native编译配置文件，并不进行真正的编译环节，再linux平台上，能生成makefile，windows上生成MSVC.sln工程文件

tlog文件

PDB文件主要用于存储VS调试程序时所需要的基本信息如源文件名、变量名、函数名等

EXP导出库文件，包含了导出函数和数据项的信息，当LIB创建一个导入库时，会同时创建一个导出库文件

vcxproj文件用于存储C++项目配置信息

std::function可以存储任何可调用对象，并允许在运行时调用它

Pluma用于管理插件的开源架构

PLUMA_PROVIDer_TYPE声明插件接口对应的Provider类的类型名称

CRITICAL_SECTION是windows中用于实现线程同步的一种机制。它允许多个线程同时访问共享资源，但同一时间只有一个线程可以执行临界区内的代码

QStringRef the wrapper of QString substrings只读，是一种引用，只有被引用的QString存在时才有效

QSignalMapper将相似发送方的信号收集起来，根据发送方绑定的标识重新分发信号

```q
//绑定
connect(button, SIGNAL(clicked()), signalMapper, SLOT(map()));
signalMapper->setMapping(button, texts[i]);//标识
connect(signalMapper, SIGNAL(mapped(QString)), this, SIGNAL(clicked(QString)));
```

lambda函数

[](){}

捕获列表：=按值捕获，&按引用捕获

参数列表

函数体

QSet无序，内部由QHash实现，只能存储可被赋值的数据类型（int、double、QString、QDate等），不可以存储QObject及其子类，而应存储它们的指针

QFile路径使用“/”，不支持“\”

stdin、stdout、stderr

当一个用户进程被创建时，与之对应的三个数据流（stdin、stdout、stderr）也会被创建

stdin：标准输入文件，对应键盘

stdout：标准输出文件，通常对应终端屏幕，存在缓冲区

stderr：标准错误输出文件，通常对应终端屏幕，不存在缓冲区

QXmlStreamReader xml流读取，从一个IO设备如QFile

QXmlStreamWriter xml流写入，输出到文件QFile或stdout

moveToThread更改此对象及其子对象的线程关联，主线程创建一个新线程指针，moveToThread将QObject对象移动到新线程中，此时与该对象的交互只能通过信号槽

QSharedPointer共享动态分配对象的所有权，使用引用计数来追踪对象的使用，作用域外引用计数-1，引用计数为0时自动销毁

QWeakPointer不会增加引用计数，不会影响对象的生命周期，当对象释放时置空

QScopedPointer独占所有权

QPointer对象删除后，指针自动置空

QThreadPool每一个Qt应用程序都有一个全局QThreadPool对象，可以通过globalInstance()访问线程池对象

创建一个QRunnable子类，并实现run虚函数，将子类对象传递给线程池的start方法

QPluginLoader调用load()动态加载.dll，instance()获取插件实例对象，但会隐式尝试load插件，如果插件还没有被load的话

QEvent当事件发生时，会构建一个QEvent子类，，通过调用notify()将事件对象进行分发

event函数与事件处理函数的关系：event()负责把事件传递给目标对象并调用对应的事件处理函数处理事件

事件 -> exec() -> notify() -> QObject::event() -> 事件处理函数如keyPressEvent

QBuffer、QTcpSocket、QFile继承自QIODevice

QByteArray、QDataStream、QTextStream独立

字符转换为二进制存储：先利用字符集如Unicode将字符转为数值，再用二进制编码方式如UTF-8将数值编码为二进制形式

QString为UTF-16编码后的Unicode文本，QByteArray没有经过编码，储存的是原始数据

QString的字符单元是QChar，QByteArray的字节单元是char

_CrtSetBreakAlloc()解决HEAP CORRUPTION内存泄漏问题

动态库显式调用

QLibrary mylib("/xxx/xxx/test/dd.so")参数为库地址

mylib.load()加载动态库

C++ Library

生成.dll后，新建lib和include文件夹，lib中放.dll文件，include中放.h文件

在.pro文件中配置INCLUDEPATH += $$PWD/include LIBS += -L $$PWD/lib -lMydll

引入动态库头文件并定义动态库对象

动态库隐式调用：添加库 -> 外部库

Qt中，子对象和父对象需要在同一线程，当一个事件发生时，Qt会将其分发到相应的对象进行处理，如果子对象和父对象不在同一线程，那么它们之间的通信可能会出现问题，因为不同线程之间无法直接访问对方的对象

QObject及其所有子类都**不是**线程安全的，当从另一个线程访问一个QObject对象时，该对象可能正在处理所在线程的事件，对其处理时要加锁；不能在另一个线程中直接删除一个QObject对象，应调用QObject::deleteLater()向对象所在线程发送一个删除事件

sendEvent()阻塞式，直接跳过事件循环队列，同一线程

postEvent()非阻塞，发送事件后返回，跨线程

多线程

可重入：多线程中同时调用但每个线程都有**独立数据**

线程安全：多线程中同时调用，即使使用**共享数据**

线程安全一定可重入，可重入不一定线程安全

C++类通常是可重入的，类实例只能获取到它们自己的成员变量数据，当一个线程中调用一个实例的成员函数时，其他线程不可以同时调用相同实例的成员函数

Qt Concurrent异步

QString存储字符串采用的是Uniccode码，每个字符是一个16位的QChar

std::function 定义可调用对象

std::bind 将可调用对象和参数一起绑定，绑定后的结果使用std::function保存并延迟调用到任何需要的时候

model是视图到原始数据的接口，以表格为层次结构表示数据，视图组件通过这种规则来存取模型中的数据，widget相当于把模型和视图结合到一起

QModelIndex模型索引

代理在视图组件上为编辑数据提供编辑器，代理从model获取相应数据，然后显示在编辑器里，修改数据后，又将其保存到model中

如果widget上已经有layout，则不能install anather layout，要先移除当前layout

toLatin1()将字符串转换为Latin1编码的QByteArray

toLocal8Bit()本地操作系统设置的字符集编码一般为GB2312

无法定位程序输入点：生成.exe所使用的lib文件的版本和在运行.exe时所调用的dll版本不一致，也可能是Qt版本不同

跨进程通信：共享内存、信号量、管道、QSharedMemory、QLocalServer/QLocalSocket

QDataStream保存文件时使用的数据编码方式有两种：

1. 用Qt预定义编码保存各种类型数据的文件，定义文件后缀为.stm
2. 标准编码数据文件，定义文件后缀为.dat，完全使用数据的二进制原始内容

字符编码：将字符集中的**字符**转换为计算机可以理解和处理的**数字**

字符集：一个系统可以处理的所有字符的集合，如ASCII字符集包含了基本的拉丁字母、数字和一些标点符号

码点：对字符集中每个字符的唯一标识，通常是一个数字编号

编码方式：指如何将码点转换为二进制数据

在简体中文windows os中，ANSI代表GB2312，在繁体中代表Big5、

ANSI并不是一种特定编码，而是不同地区扩展编码方式的统称

std::move 将一个对象的所有权转移给另一个对象

派生类定义析构函数最好显式声明为override，否则可能隐藏基类析构函数或被误认为是一个析构函数重载
