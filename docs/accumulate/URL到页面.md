###### 判断是搜索还是网址

如果是搜索内容，将搜索内容和默认搜索引擎合成新的url，如果符合url规则，根据URL协议，在输入内容上加上协议组成合法的url

###### 检查缓存

- 强缓存：命中就直接从内存或硬盘里拿到资源，否则进行协商缓存
- 协商缓存：发送请求确认资源是否过期，304就直接获取，已过期就重新发起请求

###### DNS解析

1. 递归和迭代查询
2. 多级缓存：浏览器缓存，操作系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，权威域名服务器缓存
3. 负载均衡

###### 发起TCP连接

1. 三次握手

###### https需要进行TLS四次握手

###### 发送HTTP请求

1. 请求行    eg: GET index.html HTTP/1.1
2. 请求报头
3. 空行
4. 请求正文

###### 服务器处理请求并返回HTTP报文

1. 响应行
2. 响应报头
3. 空行
4. 响应正文

###### 浏览器解析渲染页面

[![Lwi3kt.jpg](https://s1.ax1x.com/2022/04/18/Lwi3kt.jpg)](https://imgtu.com/i/Lwi3kt)

1. 解析HTML形成DOM树

   [![LYPQbT.png](https://s1.ax1x.com/2022/04/16/LYPQbT.png)](https://imgtu.com/i/LYPQbT)

   - Bytes（字节） -> Character（字符） -> Tokens（词）-> Nodes（节点）-> DOM（DOM树）

     ① 通过指定编码（http响应头部Content-Type: text/html;charset=UTF-8，html文件中的meta标签中指定charset="UTF-8"）将字节转化为字符

     ② 通过词法分析，将字符串解析成有语义的标签、属性、文本等

     ③ 根据token创建节点对象

     ④ 将各节点根据父子关系构建成DOM树

2. 解析CSS（从右向左，先子节点）形成CSSOM 树

   - 节点样式可以继承，所以通常要递归DOM树来得到节点样式，所以DOM树要小，css尽量用id或class选择器，少用标签选择器

3. JS解析（同步和异步 async和defer）

4. DOM解析

5. 合并DOM树和CSSOM树形成渲染树

   - 渲染树并不是等到DOM树和CSSOM树构建完成才开始

6. **浏览器开始渲染并绘制页面**

   - 对元素进行定位布局layout
     - 分层：脱离文档流的元素会形成一个**层叠上下文**，被提升为单独的图层，然后主线程为每个图层计算样式，**把每一个图层的绘制拆分成很多小的绘制指令，生成绘制表**，这个表记录了绘制的顺序和绘制指令
     - **合成器线程**将图层分块，交给**栅格化线程**，合成器线程会收集栅格化线程的图块信息，生成一个**合成器帧**，浏览器进程再将合成器帧绘制到显存中，再通过 GPU 渲染在屏幕上
     - 栅格化线程栅格化每个图块，再将栅格化之后的图块存储在`GPU内存`中
   - 绘制元素的样式

- 回流reflow 重绘repaint：重排和重绘都是运行在主线程上，而JS也是在主线程上执行，就会出现抢占执行时间的问题，而transform实现的动画直接运行在合成器线程和栅格化线程中，不会受到主线程JS执行的影响，也就不会存在动画卡帧的现象

- HTML解析器和CSS解析器是并行执行的，但link引入的css会阻塞浏览器渲染和后面js语句的执行
  - js会阻塞后续DOM解析、页面渲染、后续js的执行
  
- 回流重绘优化：

  - 避免使用table布局。
  - 尽可能在DOM树的最末端改变class。
  
  - 避免设置多层内联样式。
  - 将动画效果应用到position属性为absolute或fixed的元素上。
  
  - 避免使用CSS表达式（例如：calc()）
  - 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
  
  - 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
  - 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
  
  - 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
  - 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流

###### 连接结束

1. 四次挥手

###### 从浏览器的角度

从浏览器输入 `URL` 到页面渲染的整个过程都是由 浏览器架构中的各个进程之间的配合完成

进程：CPU资源分配的最小单位

线程：CPU调度的最小单位

[![Oaogmt.jpg](https://s1.ax1x.com/2022/05/11/Oaogmt.jpg)](https://imgtu.com/i/Oaogmt)

因为浏览器是多进程的

- 浏览器主进程: 管理子进程、提供服务功能
- **渲染进程**：即**浏览器内核**，内部多线程；为每一个tab页面创建一个渲染进程，互不影响；主要作用是页面渲染、脚本执行和事件处理
- GPU进程：本来是负责处理3Dcss的，后来慢慢的UI界面也交给GPU来绘制
- 网络进程：就是负责网络请求，网络资源加载的进程
- 插件进程：负责插件的运行的，因为插件很容易崩溃，把它放到独立的进程里不要让它影响别人

***

渲染进程的主要线程

- GUI渲染线程
  - 负责渲染浏览器界面，解析HTML和CSS，构建DOM Tree和CSSOM并生成Render Tree，**回流和重绘**
  - 与JS引擎线程互斥，当渲染过程中遇到script标签，渲染进程被挂起，JS引擎线程开始工作，执行完毕后，渲染线程继续渲染
- JS引擎线程
  - 即JS内核，执行JS脚本，与GUI渲染线程互斥
- 事件触发线程
  - 控制事件循环，管理任务队列（task queue）
  - 当JS执行中遇到了异步操作或事件绑定，事件触发线程会将对应的事件添加到对应的线程（定时器操事件添加到定时器触发线程，异步请求事件添加到异步请求线程），当事件结束，将回调函数添加到任务队列中等待JS引擎线程执行
- 定时器触发线程
  - `setInterval` 与 `setTimeout` 所在线程
- 异步http请求线程
  - 当执行一个异步请求时，把异步请求事件添加到异步请求线程，等收到响应，就将回调函数添加到任务队列
